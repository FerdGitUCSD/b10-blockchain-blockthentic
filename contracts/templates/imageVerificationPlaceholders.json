{
  "categories": {
    "photography": {
      "struct": "struct Image {\n        bytes32 imageHash;\n        bytes32 metadataHash;\n        address registrant;\n        uint256 registeredAt;\n        string uri;\n        string imageType;\n        bytes32 perceptualHash;\n        string cameraMake;\n    }",
      "events": "event ImageRegistered(\n        bytes32 indexed imageId,\n        bytes32 indexed imageHash,\n        address indexed registrant,\n        string uri,\n        string imageType,\n        string cameraMake,\n        uint256 timestamp\n    );",
      "batchEvents": "event BatchImagesRegistered(\n        bytes32[] imageIds,\n        bytes32[] imageHashes,\n        address indexed registrant,\n        uint256 timestamp\n    );",
      "registerFunction": "function registerImage(\n        bytes32 imageId,\n        bytes32 imageHash,\n        bytes32 metadataHash,\n        string calldata uri,\n        string calldata imageType,\n        bytes32 perceptualHash,\n        string calldata cameraMake\n    ) external onlyOwner {\n        require(images[imageId].registeredAt == 0, \"Image already registered\");\n        require(imageHash != bytes32(0), \"Invalid image hash\");\n\n        images[imageId] = Image({\n            imageHash: imageHash,\n            metadataHash: metadataHash,\n            registrant: msg.sender,\n            registeredAt: block.timestamp,\n            uri: uri,\n            imageType: imageType,\n            perceptualHash: perceptualHash,\n            cameraMake: cameraMake\n        });\n\n        imageIds.push(imageId);\n        revocationRegistry.register(imageId);\n\n        emit ImageRegistered(imageId, imageHash, msg.sender, uri, imageType, cameraMake, block.timestamp);\n    }",
      "batchRegisterFunction": "function registerImageBatch(\n        bytes32[] calldata _imageIds,\n        bytes32[] calldata imageHashes,\n        bytes32[] calldata metadataHashes,\n        string[] calldata uris,\n        string[] calldata imageTypes,\n        bytes32[] calldata perceptualHashes,\n        string[] calldata cameraMakes\n    ) external onlyOwner {\n        require(_imageIds.length == imageHashes.length, \"Array length mismatch\");\n        require(_imageIds.length == metadataHashes.length, \"Array length mismatch\");\n        require(_imageIds.length == uris.length, \"Array length mismatch\");\n        require(_imageIds.length == imageTypes.length, \"Array length mismatch\");\n        require(_imageIds.length == perceptualHashes.length, \"Array length mismatch\");\n        require(_imageIds.length == cameraMakes.length, \"Array length mismatch\");\n        require(_imageIds.length > 0, \"Empty arrays\");\n\n        for (uint256 i = 0; i < _imageIds.length; i++) {\n            require(images[_imageIds[i]].registeredAt == 0, \"Image already registered\");\n            require(imageHashes[i] != bytes32(0), \"Invalid image hash\");\n\n            images[_imageIds[i]] = Image({\n                imageHash: imageHashes[i],\n                metadataHash: metadataHashes[i],\n                registrant: msg.sender,\n                registeredAt: block.timestamp,\n                uri: uris[i],\n                imageType: imageTypes[i],\n                perceptualHash: perceptualHashes[i],\n                cameraMake: cameraMakes[i]\n            });\n\n            imageIds.push(_imageIds[i]);\n        }\n\n        revocationRegistry.registerBatch(_imageIds);\n        emit BatchImagesRegistered(_imageIds, imageHashes, msg.sender, block.timestamp);\n    }",
      "verifyFunction": "function verifyImage(bytes32 imageId, bytes32 imageHash) external view returns (bool) {\n        Image memory img = images[imageId];\n        \n        if (img.registeredAt == 0 || img.imageHash != imageHash) {\n            return false;\n        }\n\n        return revocationRegistry.isValid(imageId);\n    }",
      "getImageFunction": "function getImage(bytes32 imageId) external view returns (\n        bytes32 imageHash,\n        bytes32 metadataHash,\n        address registrant,\n        uint256 registeredAt,\n        string memory uri,\n        string memory imageType\n    ) {\n        Image memory img = images[imageId];\n        require(img.registeredAt != 0, \"Image not found\");\n\n        return (\n            img.imageHash,\n            img.metadataHash,\n            img.registrant,\n            img.registeredAt,\n            img.uri,\n            img.imageType\n        );\n    }\n\n    function getImageExtended(bytes32 imageId) external view returns (\n        bytes32 perceptualHash,\n        string memory cameraMake,\n        bool isValid\n    ) {\n        Image memory img = images[imageId];\n        require(img.registeredAt != 0, \"Image not found\");\n\n        return (\n            img.perceptualHash,\n            img.cameraMake,\n            revocationRegistry.isValid(imageId)\n        );\n    }"
    },
    "media": {
      "struct": "struct Image {\n        bytes32 imageHash;\n        bytes32 metadataHash;\n        address registrant;\n        uint256 registeredAt;\n        string uri;\n        string imageType;\n        bytes32 perceptualHash;\n        string source;\n        bool aiGenerated;\n    }",
      "events": "event ImageRegistered(\n        bytes32 indexed imageId,\n        bytes32 indexed imageHash,\n        address indexed registrant,\n        string uri,\n        string imageType,\n        string source,\n        bool aiGenerated,\n        uint256 timestamp\n    );",
      "batchEvents": "event BatchImagesRegistered(\n        bytes32[] imageIds,\n        bytes32[] imageHashes,\n        address indexed registrant,\n        uint256 timestamp\n    );",
      "registerFunction": "function registerImage(\n        bytes32 imageId,\n        bytes32 imageHash,\n        bytes32 metadataHash,\n        string calldata uri,\n        string calldata imageType,\n        bytes32 perceptualHash,\n        string calldata source,\n        bool aiGenerated\n    ) external onlyOwner {\n        require(images[imageId].registeredAt == 0, \"Image already registered\");\n        require(imageHash != bytes32(0), \"Invalid image hash\");\n\n        images[imageId] = Image({\n            imageHash: imageHash,\n            metadataHash: metadataHash,\n            registrant: msg.sender,\n            registeredAt: block.timestamp,\n            uri: uri,\n            imageType: imageType,\n            perceptualHash: perceptualHash,\n            source: source,\n            aiGenerated: aiGenerated\n        });\n\n        imageIds.push(imageId);\n        revocationRegistry.register(imageId);\n\n        emit ImageRegistered(imageId, imageHash, msg.sender, uri, imageType, source, aiGenerated, block.timestamp);\n    }",
      "batchRegisterFunction": "function registerImageBatch(\n        bytes32[] calldata _imageIds,\n        bytes32[] calldata imageHashes,\n        bytes32[] calldata metadataHashes,\n        string[] calldata uris,\n        string[] calldata imageTypes,\n        bytes32[] calldata perceptualHashes,\n        string[] calldata sources,\n        bool[] calldata aiGeneratedFlags\n    ) external onlyOwner {\n        require(_imageIds.length == imageHashes.length, \"Array length mismatch\");\n        require(_imageIds.length == metadataHashes.length, \"Array length mismatch\");\n        require(_imageIds.length == uris.length, \"Array length mismatch\");\n        require(_imageIds.length == imageTypes.length, \"Array length mismatch\");\n        require(_imageIds.length == perceptualHashes.length, \"Array length mismatch\");\n        require(_imageIds.length == sources.length, \"Array length mismatch\");\n        require(_imageIds.length == aiGeneratedFlags.length, \"Array length mismatch\");\n        require(_imageIds.length > 0, \"Empty arrays\");\n\n        for (uint256 i = 0; i < _imageIds.length; i++) {\n            require(images[_imageIds[i]].registeredAt == 0, \"Image already registered\");\n            require(imageHashes[i] != bytes32(0), \"Invalid image hash\");\n\n            images[_imageIds[i]] = Image({\n                imageHash: imageHashes[i],\n                metadataHash: metadataHashes[i],\n                registrant: msg.sender,\n                registeredAt: block.timestamp,\n                uri: uris[i],\n                imageType: imageTypes[i],\n                perceptualHash: perceptualHashes[i],\n                source: sources[i],\n                aiGenerated: aiGeneratedFlags[i]\n            });\n\n            imageIds.push(_imageIds[i]);\n        }\n\n        revocationRegistry.registerBatch(_imageIds);\n        emit BatchImagesRegistered(_imageIds, imageHashes, msg.sender, block.timestamp);\n    }",
      "verifyFunction": "function verifyImage(bytes32 imageId, bytes32 imageHash) external view returns (bool) {\n        Image memory img = images[imageId];\n        \n        if (img.registeredAt == 0 || img.imageHash != imageHash) {\n            return false;\n        }\n\n        return revocationRegistry.isValid(imageId);\n    }",
      "getImageFunction": "function getImage(bytes32 imageId) external view returns (\n        bytes32 imageHash,\n        bytes32 metadataHash,\n        address registrant,\n        uint256 registeredAt,\n        string memory uri,\n        string memory imageType\n    ) {\n        Image memory img = images[imageId];\n        require(img.registeredAt != 0, \"Image not found\");\n\n        return (\n            img.imageHash,\n            img.metadataHash,\n            img.registrant,\n            img.registeredAt,\n            img.uri,\n            img.imageType\n        );\n    }\n\n    function getImageExtended(bytes32 imageId) external view returns (\n        bytes32 perceptualHash,\n        string memory source,\n        bool aiGenerated,\n        bool isValid\n    ) {\n        Image memory img = images[imageId];\n        require(img.registeredAt != 0, \"Image not found\");\n\n        return (\n            img.perceptualHash,\n            img.source,\n            img.aiGenerated,\n            revocationRegistry.isValid(imageId)\n        );\n    }"
    },
    "nft": {
      "struct": "struct Image {\n        bytes32 imageHash;\n        bytes32 metadataHash;\n        address registrant;\n        uint256 registeredAt;\n        string uri;\n        string imageType;\n        bytes32 perceptualHash;\n        address tokenContract;\n        uint256 tokenId;\n    }",
      "events": "event ImageRegistered(\n        bytes32 indexed imageId,\n        bytes32 indexed imageHash,\n        address indexed registrant,\n        string uri,\n        string imageType,\n        address tokenContract,\n        uint256 tokenId,\n        uint256 timestamp\n    );",
      "batchEvents": "event BatchImagesRegistered(\n        bytes32[] imageIds,\n        bytes32[] imageHashes,\n        address indexed registrant,\n        uint256 timestamp\n    );",
      "registerFunction": "function registerImage(\n        bytes32 imageId,\n        bytes32 imageHash,\n        bytes32 metadataHash,\n        string calldata uri,\n        string calldata imageType,\n        bytes32 perceptualHash,\n        address tokenContract,\n        uint256 tokenId\n    ) external onlyOwner {\n        require(images[imageId].registeredAt == 0, \"Image already registered\");\n        require(imageHash != bytes32(0), \"Invalid image hash\");\n        require(tokenContract != address(0), \"Invalid token contract\");\n\n        images[imageId] = Image({\n            imageHash: imageHash,\n            metadataHash: metadataHash,\n            registrant: msg.sender,\n            registeredAt: block.timestamp,\n            uri: uri,\n            imageType: imageType,\n            perceptualHash: perceptualHash,\n            tokenContract: tokenContract,\n            tokenId: tokenId\n        });\n\n        imageIds.push(imageId);\n        revocationRegistry.register(imageId);\n\n        emit ImageRegistered(imageId, imageHash, msg.sender, uri, imageType, tokenContract, tokenId, block.timestamp);\n    }",
      "batchRegisterFunction": "function registerImageBatch(\n        bytes32[] calldata _imageIds,\n        bytes32[] calldata imageHashes,\n        bytes32[] calldata metadataHashes,\n        string[] calldata uris,\n        string[] calldata imageTypes,\n        bytes32[] calldata perceptualHashes,\n        address[] calldata tokenContracts,\n        uint256[] calldata tokenIds\n    ) external onlyOwner {\n        require(_imageIds.length == imageHashes.length, \"Array length mismatch\");\n        require(_imageIds.length == metadataHashes.length, \"Array length mismatch\");\n        require(_imageIds.length == uris.length, \"Array length mismatch\");\n        require(_imageIds.length == imageTypes.length, \"Array length mismatch\");\n        require(_imageIds.length == perceptualHashes.length, \"Array length mismatch\");\n        require(_imageIds.length == tokenContracts.length, \"Array length mismatch\");\n        require(_imageIds.length == tokenIds.length, \"Array length mismatch\");\n        require(_imageIds.length > 0, \"Empty arrays\");\n\n        for (uint256 i = 0; i < _imageIds.length; i++) {\n            require(images[_imageIds[i]].registeredAt == 0, \"Image already registered\");\n            require(imageHashes[i] != bytes32(0), \"Invalid image hash\");\n            require(tokenContracts[i] != address(0), \"Invalid token contract\");\n\n            images[_imageIds[i]] = Image({\n                imageHash: imageHashes[i],\n                metadataHash: metadataHashes[i],\n                registrant: msg.sender,\n                registeredAt: block.timestamp,\n                uri: uris[i],\n                imageType: imageTypes[i],\n                perceptualHash: perceptualHashes[i],\n                tokenContract: tokenContracts[i],\n                tokenId: tokenIds[i]\n            });\n\n            imageIds.push(_imageIds[i]);\n        }\n\n        revocationRegistry.registerBatch(_imageIds);\n        emit BatchImagesRegistered(_imageIds, imageHashes, msg.sender, block.timestamp);\n    }",
      "verifyFunction": "function verifyImage(bytes32 imageId, bytes32 imageHash) external view returns (bool) {\n        Image memory img = images[imageId];\n        \n        if (img.registeredAt == 0 || img.imageHash != imageHash) {\n            return false;\n        }\n\n        return revocationRegistry.isValid(imageId);\n    }",
      "getImageFunction": "function getImage(bytes32 imageId) external view returns (\n        bytes32 imageHash,\n        bytes32 metadataHash,\n        address registrant,\n        uint256 registeredAt,\n        string memory uri,\n        string memory imageType\n    ) {\n        Image memory img = images[imageId];\n        require(img.registeredAt != 0, \"Image not found\");\n\n        return (\n            img.imageHash,\n            img.metadataHash,\n            img.registrant,\n            img.registeredAt,\n            img.uri,\n            img.imageType\n        );\n    }\n\n    function getImageExtended(bytes32 imageId) external view returns (\n        bytes32 perceptualHash,\n        address tokenContract,\n        uint256 tokenId,\n        bool isValid\n    ) {\n        Image memory img = images[imageId];\n        require(img.registeredAt != 0, \"Image not found\");\n\n        return (\n            img.perceptualHash,\n            img.tokenContract,\n            img.tokenId,\n            revocationRegistry.isValid(imageId)\n        );\n    }"
    },
    "general": {
      "struct": "struct Image {\n        bytes32 imageHash;\n        bytes32 metadataHash;\n        address registrant;\n        uint256 registeredAt;\n        string uri;\n        string imageType;\n        bytes32 perceptualHash;\n    }",
      "events": "event ImageRegistered(\n        bytes32 indexed imageId,\n        bytes32 indexed imageHash,\n        address indexed registrant,\n        string uri,\n        string imageType,\n        uint256 timestamp\n    );",
      "batchEvents": "event BatchImagesRegistered(\n        bytes32[] imageIds,\n        bytes32[] imageHashes,\n        address indexed registrant,\n        uint256 timestamp\n    );",
      "registerFunction": "function registerImage(\n        bytes32 imageId,\n        bytes32 imageHash,\n        bytes32 metadataHash,\n        string calldata uri,\n        string calldata imageType,\n        bytes32 perceptualHash\n    ) external onlyOwner {\n        require(images[imageId].registeredAt == 0, \"Image already registered\");\n        require(imageHash != bytes32(0), \"Invalid image hash\");\n\n        images[imageId] = Image({\n            imageHash: imageHash,\n            metadataHash: metadataHash,\n            registrant: msg.sender,\n            registeredAt: block.timestamp,\n            uri: uri,\n            imageType: imageType,\n            perceptualHash: perceptualHash\n        });\n\n        imageIds.push(imageId);\n        revocationRegistry.register(imageId);\n\n        emit ImageRegistered(imageId, imageHash, msg.sender, uri, imageType, block.timestamp);\n    }",
      "batchRegisterFunction": "function registerImageBatch(\n        bytes32[] calldata _imageIds,\n        bytes32[] calldata imageHashes,\n        bytes32[] calldata metadataHashes,\n        string[] calldata uris,\n        string[] calldata imageTypes,\n        bytes32[] calldata perceptualHashes\n    ) external onlyOwner {\n        require(_imageIds.length == imageHashes.length, \"Array length mismatch\");\n        require(_imageIds.length == metadataHashes.length, \"Array length mismatch\");\n        require(_imageIds.length == uris.length, \"Array length mismatch\");\n        require(_imageIds.length == imageTypes.length, \"Array length mismatch\");\n        require(_imageIds.length == perceptualHashes.length, \"Array length mismatch\");\n        require(_imageIds.length > 0, \"Empty arrays\");\n\n        for (uint256 i = 0; i < _imageIds.length; i++) {\n            require(images[_imageIds[i]].registeredAt == 0, \"Image already registered\");\n            require(imageHashes[i] != bytes32(0), \"Invalid image hash\");\n\n            images[_imageIds[i]] = Image({\n                imageHash: imageHashes[i],\n                metadataHash: metadataHashes[i],\n                registrant: msg.sender,\n                registeredAt: block.timestamp,\n                uri: uris[i],\n                imageType: imageTypes[i],\n                perceptualHash: perceptualHashes[i]\n            });\n\n            imageIds.push(_imageIds[i]);\n        }\n\n        revocationRegistry.registerBatch(_imageIds);\n        emit BatchImagesRegistered(_imageIds, imageHashes, msg.sender, block.timestamp);\n    }",
      "verifyFunction": "function verifyImage(bytes32 imageId, bytes32 imageHash) external view returns (bool) {\n        Image memory img = images[imageId];\n        \n        if (img.registeredAt == 0 || img.imageHash != imageHash) {\n            return false;\n        }\n\n        return revocationRegistry.isValid(imageId);\n    }",
      "getImageFunction": "function getImage(bytes32 imageId) external view returns (\n        bytes32 imageHash,\n        bytes32 metadataHash,\n        address registrant,\n        uint256 registeredAt,\n        string memory uri,\n        string memory imageType\n    ) {\n        Image memory img = images[imageId];\n        require(img.registeredAt != 0, \"Image not found\");\n\n        return (\n            img.imageHash,\n            img.metadataHash,\n            img.registrant,\n            img.registeredAt,\n            img.uri,\n            img.imageType\n        );\n    }\n\n    function getImageExtended(bytes32 imageId) external view returns (\n        bytes32 perceptualHash,\n        bool isValid\n    ) {\n        Image memory img = images[imageId];\n        require(img.registeredAt != 0, \"Image not found\");\n\n        return (\n            img.perceptualHash,\n            revocationRegistry.isValid(imageId)\n        );\n    }"
    }
  },
  "batchInterface": "function registerBatch(bytes32[] calldata hashes) external;"
}