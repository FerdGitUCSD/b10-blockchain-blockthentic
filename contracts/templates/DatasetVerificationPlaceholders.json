{
  "categories": {
    "research": {
      "struct": "struct Dataset {\n        bytes32 dataHash;\n        address issuer;\n        uint256 registeredAt;\n        string uri;\n        string datasetType;\n        string methodology;\n        bool peerReviewed;\n    }",
      "events": "event DatasetRegistered(\n        bytes32 indexed datasetId,\n        bytes32 indexed dataHash,\n        address indexed issuer,\n        string uri,\n        string datasetType,\n        string methodology,\n        bool peerReviewed,\n        uint256 timestamp\n    );",
      "batchEvents": "event BatchDatasetsRegistered(\n        bytes32[] datasetIds,\n        bytes32[] dataHashes,\n        address indexed issuer,\n        uint256 timestamp\n    );",
      "registerFunction": "function registerDataset(\n        bytes32 datasetId,\n        bytes32 dataHash,\n        string calldata uri,\n        string calldata datasetType,\n        string calldata methodology,\n        bool peerReviewed\n    ) external onlyOwner {\n        require(datasets[datasetId].registeredAt == 0, \"Dataset already registered\");\n        require(dataHash != bytes32(0), \"Invalid data hash\");\n\n        datasets[datasetId] = Dataset({\n            dataHash: dataHash,\n            issuer: msg.sender,\n            registeredAt: block.timestamp,\n            uri: uri,\n            datasetType: datasetType,\n            methodology: methodology,\n            peerReviewed: peerReviewed\n        });\n\n        datasetIds.push(datasetId);\n        revocationRegistry.register(datasetId);\n\n        emit DatasetRegistered(datasetId, dataHash, msg.sender, uri, datasetType, methodology, peerReviewed, block.timestamp);\n    }",
      "batchRegisterFunction": "function registerDatasetBatch(\n        bytes32[] calldata _datasetIds,\n        bytes32[] calldata dataHashes,\n        string[] calldata uris,\n        string[] calldata datasetTypes,\n        string[] calldata methodologies,\n        bool[] calldata peerReviewedFlags\n    ) external onlyOwner {\n        require(_datasetIds.length == dataHashes.length, \"Array length mismatch\");\n        require(_datasetIds.length == uris.length, \"Array length mismatch\");\n        require(_datasetIds.length == datasetTypes.length, \"Array length mismatch\");\n        require(_datasetIds.length == methodologies.length, \"Array length mismatch\");\n        require(_datasetIds.length == peerReviewedFlags.length, \"Array length mismatch\");\n        require(_datasetIds.length > 0, \"Empty arrays\");\n\n        for (uint256 i = 0; i < _datasetIds.length; i++) {\n            require(datasets[_datasetIds[i]].registeredAt == 0, \"Dataset already registered\");\n            require(dataHashes[i] != bytes32(0), \"Invalid data hash\");\n\n            datasets[_datasetIds[i]] = Dataset({\n                dataHash: dataHashes[i],\n                issuer: msg.sender,\n                registeredAt: block.timestamp,\n                uri: uris[i],\n                datasetType: datasetTypes[i],\n                methodology: methodologies[i],\n                peerReviewed: peerReviewedFlags[i]\n            });\n\n            datasetIds.push(_datasetIds[i]);\n        }\n\n        revocationRegistry.registerBatch(_datasetIds);\n        emit BatchDatasetsRegistered(_datasetIds, dataHashes, msg.sender, block.timestamp);\n    }",
      "verifyFunction": "function verifyDataset(bytes32 datasetId, bytes32 dataHash) external view returns (bool) {\n        Dataset memory ds = datasets[datasetId];\n        \n        if (ds.registeredAt == 0 || ds.dataHash != dataHash) {\n            return false;\n        }\n\n        return revocationRegistry.isValid(datasetId);\n    }",
      "getDatasetFunction": "function getDataset(bytes32 datasetId) external view returns (\n        bytes32 dataHash,\n        address issuer,\n        uint256 registeredAt,\n        string memory uri,\n        string memory datasetType,\n        bool isValid\n    ) {\n        Dataset memory ds = datasets[datasetId];\n        require(ds.registeredAt != 0, \"Dataset not found\");\n\n        return (\n            ds.dataHash,\n            ds.issuer,\n            ds.registeredAt,\n            ds.uri,\n            ds.datasetType,\n            revocationRegistry.isValid(datasetId)\n        );\n    }\n\n    function getDatasetExtended(bytes32 datasetId) external view returns (\n        string memory methodology,\n        bool peerReviewed,\n        bool isValid\n    ) {\n        Dataset memory ds = datasets[datasetId];\n        require(ds.registeredAt != 0, \"Dataset not found\");\n\n        return (\n            ds.methodology,\n            ds.peerReviewed,\n            revocationRegistry.isValid(datasetId)\n        );\n    }"
    },
    "government": {
      "struct": "struct Dataset {\n        bytes32 dataHash;\n        address issuer;\n        uint256 registeredAt;\n        string uri;\n        string datasetType;\n        string agency;\n        string classification;\n    }",
      "events": "event DatasetRegistered(\n        bytes32 indexed datasetId,\n        bytes32 indexed dataHash,\n        address indexed issuer,\n        string uri,\n        string datasetType,\n        string agency,\n        string classification,\n        uint256 timestamp\n    );",
      "batchEvents": "event BatchDatasetsRegistered(\n        bytes32[] datasetIds,\n        bytes32[] dataHashes,\n        address indexed issuer,\n        uint256 timestamp\n    );",
      "registerFunction": "function registerDataset(\n        bytes32 datasetId,\n        bytes32 dataHash,\n        string calldata uri,\n        string calldata datasetType,\n        string calldata agency,\n        string calldata classification\n    ) external onlyOwner {\n        require(datasets[datasetId].registeredAt == 0, \"Dataset already registered\");\n        require(dataHash != bytes32(0), \"Invalid data hash\");\n\n        datasets[datasetId] = Dataset({\n            dataHash: dataHash,\n            issuer: msg.sender,\n            registeredAt: block.timestamp,\n            uri: uri,\n            datasetType: datasetType,\n            agency: agency,\n            classification: classification\n        });\n\n        datasetIds.push(datasetId);\n        revocationRegistry.register(datasetId);\n\n        emit DatasetRegistered(datasetId, dataHash, msg.sender, uri, datasetType, agency, classification, block.timestamp);\n    }",
      "batchRegisterFunction": "function registerDatasetBatch(\n        bytes32[] calldata _datasetIds,\n        bytes32[] calldata dataHashes,\n        string[] calldata uris,\n        string[] calldata datasetTypes,\n        string[] calldata agencies,\n        string[] calldata classifications\n    ) external onlyOwner {\n        require(_datasetIds.length == dataHashes.length, \"Array length mismatch\");\n        require(_datasetIds.length == uris.length, \"Array length mismatch\");\n        require(_datasetIds.length == datasetTypes.length, \"Array length mismatch\");\n        require(_datasetIds.length == agencies.length, \"Array length mismatch\");\n        require(_datasetIds.length == classifications.length, \"Array length mismatch\");\n        require(_datasetIds.length > 0, \"Empty arrays\");\n\n        for (uint256 i = 0; i < _datasetIds.length; i++) {\n            require(datasets[_datasetIds[i]].registeredAt == 0, \"Dataset already registered\");\n            require(dataHashes[i] != bytes32(0), \"Invalid data hash\");\n\n            datasets[_datasetIds[i]] = Dataset({\n                dataHash: dataHashes[i],\n                issuer: msg.sender,\n                registeredAt: block.timestamp,\n                uri: uris[i],\n                datasetType: datasetTypes[i],\n                agency: agencies[i],\n                classification: classifications[i]\n            });\n\n            datasetIds.push(_datasetIds[i]);\n        }\n\n        revocationRegistry.registerBatch(_datasetIds);\n        emit BatchDatasetsRegistered(_datasetIds, dataHashes, msg.sender, block.timestamp);\n    }",
      "verifyFunction": "function verifyDataset(bytes32 datasetId, bytes32 dataHash) external view returns (bool) {\n        Dataset memory ds = datasets[datasetId];\n        \n        if (ds.registeredAt == 0 || ds.dataHash != dataHash) {\n            return false;\n        }\n\n        return revocationRegistry.isValid(datasetId);\n    }",
      "getDatasetFunction": "function getDataset(bytes32 datasetId) external view returns (\n        bytes32 dataHash,\n        address issuer,\n        uint256 registeredAt,\n        string memory uri,\n        string memory datasetType,\n        bool isValid\n    ) {\n        Dataset memory ds = datasets[datasetId];\n        require(ds.registeredAt != 0, \"Dataset not found\");\n\n        return (\n            ds.dataHash,\n            ds.issuer,\n            ds.registeredAt,\n            ds.uri,\n            ds.datasetType,\n            revocationRegistry.isValid(datasetId)\n        );\n    }\n\n    function getDatasetExtended(bytes32 datasetId) external view returns (\n        string memory agency,\n        string memory classification,\n        bool isValid\n    ) {\n        Dataset memory ds = datasets[datasetId];\n        require(ds.registeredAt != 0, \"Dataset not found\");\n\n        return (\n            ds.agency,\n            ds.classification,\n            revocationRegistry.isValid(datasetId)\n        );\n    }"
    },
    "ml": {
      "struct": "struct Dataset {\n        bytes32 dataHash;\n        address issuer;\n        uint256 registeredAt;\n        string uri;\n        string datasetType;\n        string license;\n        string modelVersion;\n    }",
      "events": "event DatasetRegistered(\n        bytes32 indexed datasetId,\n        bytes32 indexed dataHash,\n        address indexed issuer,\n        string uri,\n        string datasetType,\n        string license,\n        string modelVersion,\n        uint256 timestamp\n    );",
      "batchEvents": "event BatchDatasetsRegistered(\n        bytes32[] datasetIds,\n        bytes32[] dataHashes,\n        address indexed issuer,\n        uint256 timestamp\n    );",
      "registerFunction": "function registerDataset(\n        bytes32 datasetId,\n        bytes32 dataHash,\n        string calldata uri,\n        string calldata datasetType,\n        string calldata license,\n        string calldata modelVersion\n    ) external onlyOwner {\n        require(datasets[datasetId].registeredAt == 0, \"Dataset already registered\");\n        require(dataHash != bytes32(0), \"Invalid data hash\");\n\n        datasets[datasetId] = Dataset({\n            dataHash: dataHash,\n            issuer: msg.sender,\n            registeredAt: block.timestamp,\n            uri: uri,\n            datasetType: datasetType,\n            license: license,\n            modelVersion: modelVersion\n        });\n\n        datasetIds.push(datasetId);\n        revocationRegistry.register(datasetId);\n\n        emit DatasetRegistered(datasetId, dataHash, msg.sender, uri, datasetType, license, modelVersion, block.timestamp);\n    }",
      "batchRegisterFunction": "function registerDatasetBatch(\n        bytes32[] calldata _datasetIds,\n        bytes32[] calldata dataHashes,\n        string[] calldata uris,\n        string[] calldata datasetTypes,\n        string[] calldata licenses,\n        string[] calldata modelVersions\n    ) external onlyOwner {\n        require(_datasetIds.length == dataHashes.length, \"Array length mismatch\");\n        require(_datasetIds.length == uris.length, \"Array length mismatch\");\n        require(_datasetIds.length == datasetTypes.length, \"Array length mismatch\");\n        require(_datasetIds.length == licenses.length, \"Array length mismatch\");\n        require(_datasetIds.length == modelVersions.length, \"Array length mismatch\");\n        require(_datasetIds.length > 0, \"Empty arrays\");\n\n        for (uint256 i = 0; i < _datasetIds.length; i++) {\n            require(datasets[_datasetIds[i]].registeredAt == 0, \"Dataset already registered\");\n            require(dataHashes[i] != bytes32(0), \"Invalid data hash\");\n\n            datasets[_datasetIds[i]] = Dataset({\n                dataHash: dataHashes[i],\n                issuer: msg.sender,\n                registeredAt: block.timestamp,\n                uri: uris[i],\n                datasetType: datasetTypes[i],\n                license: licenses[i],\n                modelVersion: modelVersions[i]\n            });\n\n            datasetIds.push(_datasetIds[i]);\n        }\n\n        revocationRegistry.registerBatch(_datasetIds);\n        emit BatchDatasetsRegistered(_datasetIds, dataHashes, msg.sender, block.timestamp);\n    }",
      "verifyFunction": "function verifyDataset(bytes32 datasetId, bytes32 dataHash) external view returns (bool) {\n        Dataset memory ds = datasets[datasetId];\n        \n        if (ds.registeredAt == 0 || ds.dataHash != dataHash) {\n            return false;\n        }\n\n        return revocationRegistry.isValid(datasetId);\n    }",
      "getDatasetFunction": "function getDataset(bytes32 datasetId) external view returns (\n        bytes32 dataHash,\n        address issuer,\n        uint256 registeredAt,\n        string memory uri,\n        string memory datasetType,\n        bool isValid\n    ) {\n        Dataset memory ds = datasets[datasetId];\n        require(ds.registeredAt != 0, \"Dataset not found\");\n\n        return (\n            ds.dataHash,\n            ds.issuer,\n            ds.registeredAt,\n            ds.uri,\n            ds.datasetType,\n            revocationRegistry.isValid(datasetId)\n        );\n    }\n\n    function getDatasetExtended(bytes32 datasetId) external view returns (\n        string memory license,\n        string memory modelVersion,\n        bool isValid\n    ) {\n        Dataset memory ds = datasets[datasetId];\n        require(ds.registeredAt != 0, \"Dataset not found\");\n\n        return (\n            ds.license,\n            ds.modelVersion,\n            revocationRegistry.isValid(datasetId)\n        );\n    }"
    },
    "general": {
      "struct": "struct Dataset {\n        bytes32 dataHash;\n        address issuer;\n        uint256 registeredAt;\n        string uri;\n        string datasetType;\n    }",
      "events": "event DatasetRegistered(\n        bytes32 indexed datasetId,\n        bytes32 indexed dataHash,\n        address indexed issuer,\n        string uri,\n        string datasetType,\n        uint256 timestamp\n    );",
      "batchEvents": "event BatchDatasetsRegistered(\n        bytes32[] datasetIds,\n        bytes32[] dataHashes,\n        address indexed issuer,\n        uint256 timestamp\n    );",
      "registerFunction": "function registerDataset(\n        bytes32 datasetId,\n        bytes32 dataHash,\n        string calldata uri,\n        string calldata datasetType\n    ) external onlyOwner {\n        require(datasets[datasetId].registeredAt == 0, \"Dataset already registered\");\n        require(dataHash != bytes32(0), \"Invalid data hash\");\n\n        datasets[datasetId] = Dataset({\n            dataHash: dataHash,\n            issuer: msg.sender,\n            registeredAt: block.timestamp,\n            uri: uri,\n            datasetType: datasetType\n        });\n\n        datasetIds.push(datasetId);\n        revocationRegistry.register(datasetId);\n\n        emit DatasetRegistered(datasetId, dataHash, msg.sender, uri, datasetType, block.timestamp);\n    }",
      "batchRegisterFunction": "function registerDatasetBatch(\n        bytes32[] calldata _datasetIds,\n        bytes32[] calldata dataHashes,\n        string[] calldata uris,\n        string[] calldata datasetTypes\n    ) external onlyOwner {\n        require(_datasetIds.length == dataHashes.length, \"Array length mismatch\");\n        require(_datasetIds.length == uris.length, \"Array length mismatch\");\n        require(_datasetIds.length == datasetTypes.length, \"Array length mismatch\");\n        require(_datasetIds.length > 0, \"Empty arrays\");\n\n        for (uint256 i = 0; i < _datasetIds.length; i++) {\n            require(datasets[_datasetIds[i]].registeredAt == 0, \"Dataset already registered\");\n            require(dataHashes[i] != bytes32(0), \"Invalid data hash\");\n\n            datasets[_datasetIds[i]] = Dataset({\n                dataHash: dataHashes[i],\n                issuer: msg.sender,\n                registeredAt: block.timestamp,\n                uri: uris[i],\n                datasetType: datasetTypes[i]\n            });\n\n            datasetIds.push(_datasetIds[i]);\n        }\n\n        revocationRegistry.registerBatch(_datasetIds);\n        emit BatchDatasetsRegistered(_datasetIds, dataHashes, msg.sender, block.timestamp);\n    }",
      "verifyFunction": "function verifyDataset(bytes32 datasetId, bytes32 dataHash) external view returns (bool) {\n        Dataset memory ds = datasets[datasetId];\n        \n        if (ds.registeredAt == 0 || ds.dataHash != dataHash) {\n            return false;\n        }\n\n        return revocationRegistry.isValid(datasetId);\n    }",
      "getDatasetFunction": "function getDataset(bytes32 datasetId) external view returns (\n        bytes32 dataHash,\n        address issuer,\n        uint256 registeredAt,\n        string memory uri,\n        string memory datasetType,\n        bool isValid\n    ) {\n        Dataset memory ds = datasets[datasetId];\n        require(ds.registeredAt != 0, \"Dataset not found\");\n\n        return (\n            ds.dataHash,\n            ds.issuer,\n            ds.registeredAt,\n            ds.uri,\n            ds.datasetType,\n            revocationRegistry.isValid(datasetId)\n        );\n    }"
    }
  },
  "batchInterface": "function registerBatch(bytes32[] calldata hashes) external;"
}