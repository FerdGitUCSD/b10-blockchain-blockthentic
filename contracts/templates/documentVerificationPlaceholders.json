{
  "categories": {
    "academic": {
      "struct": "struct Document {\n        bytes32 docHash;\n        address issuer;\n        uint256 issuedAt;\n        string uri;\n        string credentialType;\n    }",
      "events": "event DocumentRegistered(\n        bytes32 indexed docId,\n        bytes32 indexed docHash,\n        address indexed issuer,\n        string uri,\n        string credentialType,\n        uint256 timestamp\n    );",
      "batchEvents": "event BatchDocumentsRegistered(\n        bytes32[] docIds,\n        bytes32[] docHashes,\n        address indexed issuer,\n        uint256 timestamp\n    );",
      "registerFunction": "function registerDocument(\n        bytes32 docId,\n        bytes32 docHash,\n        string calldata uri,\n        string calldata credentialType\n    ) external onlyOwner {\n        require(documents[docId].issuedAt == 0, \"Document already registered\");\n        require(docHash != bytes32(0), \"Invalid document hash\");\n\n        documents[docId] = Document({\n            docHash: docHash,\n            issuer: msg.sender,\n            issuedAt: block.timestamp,\n            uri: uri,\n            credentialType: credentialType\n        });\n\n        documentIds.push(docId);\n        revocationRegistry.register(docId);\n\n        emit DocumentRegistered(docId, docHash, msg.sender, uri, credentialType, block.timestamp);\n    }",
      "batchRegisterFunction": "function registerDocumentBatch(\n        bytes32[] calldata docIds,\n        bytes32[] calldata docHashes,\n        string[] calldata uris,\n        string[] calldata credentialTypes\n    ) external onlyOwner {\n        require(docIds.length == docHashes.length, \"Array length mismatch\");\n        require(docIds.length == uris.length, \"Array length mismatch\");\n        require(docIds.length == credentialTypes.length, \"Array length mismatch\");\n        require(docIds.length > 0, \"Empty arrays\");\n\n        for (uint256 i = 0; i < docIds.length; i++) {\n            require(documents[docIds[i]].issuedAt == 0, \"Document already registered\");\n            require(docHashes[i] != bytes32(0), \"Invalid document hash\");\n\n            documents[docIds[i]] = Document({\n                docHash: docHashes[i],\n                issuer: msg.sender,\n                issuedAt: block.timestamp,\n                uri: uris[i],\n                credentialType: credentialTypes[i]\n            });\n\n            documentIds.push(docIds[i]);\n        }\n\n        revocationRegistry.registerBatch(docIds);\n        emit BatchDocumentsRegistered(docIds, docHashes, msg.sender, block.timestamp);\n    }",
      "verifyFunction": "function verifyDocument(bytes32 docId, bytes32 docHash) external view returns (bool) {\n        Document memory doc = documents[docId];\n        \n        if (doc.issuedAt == 0 || doc.docHash != docHash) {\n            return false;\n        }\n\n        return revocationRegistry.isValid(docId);\n    }",
      "getDocumentFunction": "function getDocument(bytes32 docId) external view returns (\n        bytes32 docHash,\n        address issuer,\n        uint256 issuedAt,\n        string memory uri,\n        string memory credentialType,\n        bool isValid\n    ) {\n        Document memory doc = documents[docId];\n        require(doc.issuedAt != 0, \"Document not found\");\n\n        return (\n            doc.docHash,\n            doc.issuer,\n            doc.issuedAt,\n            doc.uri,\n            doc.credentialType,\n            revocationRegistry.isValid(docId)\n        );\n    }"
    },
    "legal": {
      "struct": "struct Document {\n        bytes32 docHash;\n        address issuer;\n        uint256 issuedAt;\n        string uri;\n        string documentType;\n        uint256 expiresAt;\n    }",
      "events": "event DocumentRegistered(\n        bytes32 indexed docId,\n        bytes32 indexed docHash,\n        address indexed issuer,\n        string uri,\n        string documentType,\n        uint256 expiresAt,\n        uint256 timestamp\n    );",
      "batchEvents": "event BatchDocumentsRegistered(\n        bytes32[] docIds,\n        bytes32[] docHashes,\n        address indexed issuer,\n        uint256 timestamp\n    );",
      "registerFunction": "function registerDocument(\n        bytes32 docId,\n        bytes32 docHash,\n        string calldata uri,\n        string calldata documentType,\n        uint256 expiresAt\n    ) external onlyOwner {\n        require(documents[docId].issuedAt == 0, \"Document already registered\");\n        require(docHash != bytes32(0), \"Invalid document hash\");\n        require(expiresAt == 0 || expiresAt > block.timestamp, \"Invalid expiration\");\n\n        documents[docId] = Document({\n            docHash: docHash,\n            issuer: msg.sender,\n            issuedAt: block.timestamp,\n            uri: uri,\n            documentType: documentType,\n            expiresAt: expiresAt\n        });\n\n        documentIds.push(docId);\n        revocationRegistry.register(docId);\n\n        emit DocumentRegistered(docId, docHash, msg.sender, uri, documentType, expiresAt, block.timestamp);\n    }",
      "batchRegisterFunction": "function registerDocumentBatch(\n        bytes32[] calldata docIds,\n        bytes32[] calldata docHashes,\n        string[] calldata uris,\n        string[] calldata documentTypes,\n        uint256[] calldata expirations\n    ) external onlyOwner {\n        require(docIds.length == docHashes.length, \"Array length mismatch\");\n        require(docIds.length == uris.length, \"Array length mismatch\");\n        require(docIds.length == documentTypes.length, \"Array length mismatch\");\n        require(docIds.length == expirations.length, \"Array length mismatch\");\n        require(docIds.length > 0, \"Empty arrays\");\n\n        for (uint256 i = 0; i < docIds.length; i++) {\n            require(documents[docIds[i]].issuedAt == 0, \"Document already registered\");\n            require(docHashes[i] != bytes32(0), \"Invalid document hash\");\n            require(expirations[i] == 0 || expirations[i] > block.timestamp, \"Invalid expiration\");\n\n            documents[docIds[i]] = Document({\n                docHash: docHashes[i],\n                issuer: msg.sender,\n                issuedAt: block.timestamp,\n                uri: uris[i],\n                documentType: documentTypes[i],\n                expiresAt: expirations[i]\n            });\n\n            documentIds.push(docIds[i]);\n        }\n\n        revocationRegistry.registerBatch(docIds);\n        emit BatchDocumentsRegistered(docIds, docHashes, msg.sender, block.timestamp);\n    }",
      "verifyFunction": "function verifyDocument(bytes32 docId, bytes32 docHash) external view returns (bool) {\n        Document memory doc = documents[docId];\n        \n        if (doc.issuedAt == 0 || doc.docHash != docHash) {\n            return false;\n        }\n\n        // Check expiration\n        if (doc.expiresAt != 0 && block.timestamp > doc.expiresAt) {\n            return false;\n        }\n\n        return revocationRegistry.isValid(docId);\n    }",
      "getDocumentFunction": "function getDocument(bytes32 docId) external view returns (\n        bytes32 docHash,\n        address issuer,\n        uint256 issuedAt,\n        string memory uri,\n        string memory documentType,\n        uint256 expiresAt,\n        bool isValid\n    ) {\n        Document memory doc = documents[docId];\n        require(doc.issuedAt != 0, \"Document not found\");\n\n        bool valid = revocationRegistry.isValid(docId);\n        if (doc.expiresAt != 0 && block.timestamp > doc.expiresAt) {\n            valid = false;\n        }\n\n        return (\n            doc.docHash,\n            doc.issuer,\n            doc.issuedAt,\n            doc.uri,\n            doc.documentType,\n            doc.expiresAt,\n            valid\n        );\n    }"
    },
    "medical": {
      "struct": "struct Document {\n        bytes32 docHash;\n        address issuer;\n        uint256 issuedAt;\n        string uri;\n        string recordType;\n        bytes32 patientIdHash;\n    }",
      "events": "event DocumentRegistered(\n        bytes32 indexed docId,\n        bytes32 indexed docHash,\n        address indexed issuer,\n        string uri,\n        string recordType,\n        uint256 timestamp\n    );",
      "batchEvents": "event BatchDocumentsRegistered(\n        bytes32[] docIds,\n        bytes32[] docHashes,\n        address indexed issuer,\n        uint256 timestamp\n    );",
      "registerFunction": "function registerDocument(\n        bytes32 docId,\n        bytes32 docHash,\n        string calldata uri,\n        string calldata recordType,\n        bytes32 patientIdHash\n    ) external onlyOwner {\n        require(documents[docId].issuedAt == 0, \"Document already registered\");\n        require(docHash != bytes32(0), \"Invalid document hash\");\n        require(patientIdHash != bytes32(0), \"Invalid patient ID hash\");\n\n        documents[docId] = Document({\n            docHash: docHash,\n            issuer: msg.sender,\n            issuedAt: block.timestamp,\n            uri: uri,\n            recordType: recordType,\n            patientIdHash: patientIdHash\n        });\n\n        documentIds.push(docId);\n        revocationRegistry.register(docId);\n\n        emit DocumentRegistered(docId, docHash, msg.sender, uri, recordType, block.timestamp);\n    }",
      "batchRegisterFunction": "function registerDocumentBatch(\n        bytes32[] calldata docIds,\n        bytes32[] calldata docHashes,\n        string[] calldata uris,\n        string[] calldata recordTypes,\n        bytes32[] calldata patientIdHashes\n    ) external onlyOwner {\n        require(docIds.length == docHashes.length, \"Array length mismatch\");\n        require(docIds.length == uris.length, \"Array length mismatch\");\n        require(docIds.length == recordTypes.length, \"Array length mismatch\");\n        require(docIds.length == patientIdHashes.length, \"Array length mismatch\");\n        require(docIds.length > 0, \"Empty arrays\");\n\n        for (uint256 i = 0; i < docIds.length; i++) {\n            require(documents[docIds[i]].issuedAt == 0, \"Document already registered\");\n            require(docHashes[i] != bytes32(0), \"Invalid document hash\");\n            require(patientIdHashes[i] != bytes32(0), \"Invalid patient ID hash\");\n\n            documents[docIds[i]] = Document({\n                docHash: docHashes[i],\n                issuer: msg.sender,\n                issuedAt: block.timestamp,\n                uri: uris[i],\n                recordType: recordTypes[i],\n                patientIdHash: patientIdHashes[i]\n            });\n\n            documentIds.push(docIds[i]);\n        }\n\n        revocationRegistry.registerBatch(docIds);\n        emit BatchDocumentsRegistered(docIds, docHashes, msg.sender, block.timestamp);\n    }",
      "verifyFunction": "function verifyDocument(bytes32 docId, bytes32 docHash) external view returns (bool) {\n        Document memory doc = documents[docId];\n        \n        if (doc.issuedAt == 0 || doc.docHash != docHash) {\n            return false;\n        }\n\n        return revocationRegistry.isValid(docId);\n    }",
      "getDocumentFunction": "function getDocument(bytes32 docId) external view returns (\n        bytes32 docHash,\n        address issuer,\n        uint256 issuedAt,\n        string memory uri,\n        string memory recordType,\n        bool isValid\n    ) {\n        Document memory doc = documents[docId];\n        require(doc.issuedAt != 0, \"Document not found\");\n\n        return (\n            doc.docHash,\n            doc.issuer,\n            doc.issuedAt,\n            doc.uri,\n            doc.recordType,\n            revocationRegistry.isValid(docId)\n        );\n    }"
    },
    "general": {
      "struct": "struct Document {\n        bytes32 docHash;\n        address issuer;\n        uint256 issuedAt;\n        string uri;\n    }",
      "events": "event DocumentRegistered(\n        bytes32 indexed docId,\n        bytes32 indexed docHash,\n        address indexed issuer,\n        string uri,\n        uint256 timestamp\n    );",
      "batchEvents": "event BatchDocumentsRegistered(\n        bytes32[] docIds,\n        bytes32[] docHashes,\n        address indexed issuer,\n        uint256 timestamp\n    );",
      "registerFunction": "function registerDocument(\n        bytes32 docId,\n        bytes32 docHash,\n        string calldata uri\n    ) external onlyOwner {\n        require(documents[docId].issuedAt == 0, \"Document already registered\");\n        require(docHash != bytes32(0), \"Invalid document hash\");\n\n        documents[docId] = Document({\n            docHash: docHash,\n            issuer: msg.sender,\n            issuedAt: block.timestamp,\n            uri: uri\n        });\n\n        documentIds.push(docId);\n        revocationRegistry.register(docId);\n\n        emit DocumentRegistered(docId, docHash, msg.sender, uri, block.timestamp);\n    }",
      "batchRegisterFunction": "function registerDocumentBatch(\n        bytes32[] calldata docIds,\n        bytes32[] calldata docHashes,\n        string[] calldata uris\n    ) external onlyOwner {\n        require(docIds.length == docHashes.length, \"Array length mismatch\");\n        require(docIds.length == uris.length, \"Array length mismatch\");\n        require(docIds.length > 0, \"Empty arrays\");\n\n        for (uint256 i = 0; i < docIds.length; i++) {\n            require(documents[docIds[i]].issuedAt == 0, \"Document already registered\");\n            require(docHashes[i] != bytes32(0), \"Invalid document hash\");\n\n            documents[docIds[i]] = Document({\n                docHash: docHashes[i],\n                issuer: msg.sender,\n                issuedAt: block.timestamp,\n                uri: uris[i]\n            });\n\n            documentIds.push(docIds[i]);\n        }\n\n        revocationRegistry.registerBatch(docIds);\n        emit BatchDocumentsRegistered(docIds, docHashes, msg.sender, block.timestamp);\n    }",
      "verifyFunction": "function verifyDocument(bytes32 docId, bytes32 docHash) external view returns (bool) {\n        Document memory doc = documents[docId];\n        \n        if (doc.issuedAt == 0 || doc.docHash != docHash) {\n            return false;\n        }\n\n        return revocationRegistry.isValid(docId);\n    }",
      "getDocumentFunction": "function getDocument(bytes32 docId) external view returns (\n        bytes32 docHash,\n        address issuer,\n        uint256 issuedAt,\n        string memory uri,\n        bool isValid\n    ) {\n        Document memory doc = documents[docId];\n        require(doc.issuedAt != 0, \"Document not found\");\n\n        return (\n            doc.docHash,\n            doc.issuer,\n            doc.issuedAt,\n            doc.uri,\n            revocationRegistry.isValid(docId)\n        );\n    }"
    }
  },
  "batchInterface": "function registerBatch(bytes32[] calldata hashes) external;"
}
